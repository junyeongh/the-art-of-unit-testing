# 4장 모의 객체를 사용한 상호 작용 테스트

- **4.1 상호 작용 테스트, 목, 스텁**
- **4.2 로거 함수에 의존**
  ```
  inputs: (passwordInput, rules) |> verifyPassword
    => side-effect: log
  ```
  - 가짜 객체를 주입하는 방법
    - 표준: 매개변수 추가
    - 함수형: 커링 사용 / 고차 함수로 변환
    - 모듈형: 모듈 의존성 추상화
    - 객체 지향형: 타입이 없는 객체/인터페이스 주입
  - @ 표준 & 함수형은 직관적인데 모듈형이나 객체 지향형은 잘 모르겠음
  - 코드의 추상화와 `seam`의 사용
- **4.3 기본 스타일: 매개변수를 주입하는 방식으로 리팩터링**
  - @
    - 직관적 변수명과 좋은 코드의 중요성; 인지적 비용을 줄이는건 항상 중요하다고 느낌
    - 결국에 테스팅은 작성한 코드를 모두 이해하긴 힘든 블랙박스라는 전제를 두고 어떤 부분을 얼마나 테스팅 할거냐의 판단이라는 생각이 많이 듦. 가장 작은 단위의 유닛 테스트를 위해서 스텁/목을 구성하는 것부터 코드 베이스의 어떤 부분을 코드를 작성하는 사람의 이해가 필요 없는 블랙 박스로 바라볼지 고민이 필요한 듯. (의존성)
- **4.4 목과 스텁을 구분하는 것의 중요성**
  - @ 지금까지 목과 스텁을 단순하게 보고 있었다는 생각.
    - '목은 작업 단위의 요구 사항을 나타내고, 스텁은 들어오는 정보나 동작을 나타낸다.'
      - ==스텁(stub): 내부로 오는 의존성 대체==
        - 더미 객체
        - 테스트 스텁
      - ==목(mock): 외부로 나가는 의존성 대체==
        - 테스트 스파이
        - 모의 객체
    - 스텁은 단순히 임의의 input이라고 생각하고 있었고 이 장에서 설명하는 것도 다르지 않지만 특히 `mock`에 대해서는 '외부로 나가는 의존성'과 '작업 단위의 요구 사항'이 같은 개념이라는 건 결국 테스팅에 대상이 뭔지에 대한 중요한 시야를 주는 듯.
      - 특히 '목과 스텁을 제대로 구분하지 않으면 스텁을 검증하는 경우가 생길 수 있다. 이는 사실 무의미한 일이며 테스트와 실제 코드 간 결합도만 높일 뿐이다.' (p.163) 부분
- **4.5 모듈 스타일의 목**
  - @
    - 개인적으로 이번 장이나 지난 장의 의존성을 주입하는 방식의 코드가 별로 좋은 방법은 아닌 것 같다. 좋은 방법이 아니라기 보단 내가 선호하는 스타일의 코드가 아닌 것 같다.
    - 예제 코드를 보면서 생각을 해봤는데, 왜 스텁과 목으로 테스팅을 하는지 큰 이유 두가지를 들자면, 하나는 내가 작성한 코드가 원하는 대로 동작하는지와 다른 하나는 의존성이 제대로 동작하는지인 듯 하다. 근데 예제 코드의 경우에 logger를 의존성이라고 생각하고 verifyPassword에 logger를 붙이는 것 자체가 별로 작성이 잘 된 코드인 것 같지 않다는 생각.
    - 의존성과 파괴적 변경(breaking change), 그리고 이전 장에서 다룬 제어의 역전을 통한 의존성 관리를 생각하면 여러 코드 조각을 붙여서 하나의 프로그램을 만든다고 가정했을 때, 어떤 방식으로 코드 조각을 붙이고 그 사이의 `seam`을 고려할지도 중요한 듯 하다.
- **4.6 함수형 스타일에서 목**
  - @ 함수형의 핵심적인 부분이 pure function과 composition이라고 한다면 이 장에서 얘기하고자 하는 currying이나 partial application으로 기대하는 동작 또는 작업 단위의 요구 사항을 부분부분으로 쪼갠 다음, 의존성으로 작성되는 부분과 그렇지 않은 부분으로 나누어 작성하고 의존성 부분을 어떻게 대체할지 말하는 것 같음.
- **4.7 객체 지향 스타일의 목**
  - @
    - 이 책을 읽다보면 객체지향과 함수형을 아얘 다른 것이라고 분리를 해서 말하는 것 같다는 생각이 드는데 이전 장을 읽다 찾은 객체 지향에 대한 배경에 대한 얘기나 (이 책에서 주로 말하는 class를 사용한 객체 지향과는 다른) 자바스크립트가 가진 프로토타입을 통한 객체 지향적 언어 설계에 대한 얘기를 보다가 배운 점을 보면 객체지향과 함수형이 같이 사용될 수 없지는 않은 것 같음.
      - DI: Interface => Implementation / Type Signature => Implementation
      - seam: Interface / Type Signature
    - 결국 값 또는 상태를 OOP에서처럼 캡슐화를 하든 함수형에서처럼 아얘 가지지 않든 목을 '작업 단위의 요구 사항'인 동시에 '외부로 나가는 의존성'으로 생각하면 예제 4-12에서 주입하는 mockLog의 역할이나 이전의 예제 4-9의 방식을 다르게 볼 수 있다고 느꼈음.
- **4.8 복잡한 인터페이스 다루기 & 4.9 부분 모의 객체**
  - @ 이 책에서는 주로 테스트 자체의 방법론과 실제 작성 예시를 지금까지는 다루고 있는데 실제 있을법한 코드베이스 내의 복잡한 인터페이스를 마주친 상황과 테스트를 위해 재작성된 인터페이스를 어떻게 바라볼지에 대한 시야를 제시해주는 점이 좋은 듯. 테스트를 좋은 소프트웨어 작성을 위한 필수 요소로 본다면, 애초에 복잡한 인터페이스가 있지 않은 편이 이상적이겠지만, 실제로 내가 작성을 하든 남이 작성을 한 코드를 보면 그런 경우가 사실 많긴 하다.
  - *4.9.1 부분 모의 객체를 함수형 방식으로 풀어 보기 & 4.9.2 부분 모의 객체를 객체 지향 방식으로 풀어 보기*
    - => 두 예제 다, 부분을 어떻게 대체할지 다른 패러다임의 방식으로 설명
- **4.10 요약**
  - @
    - 다른 프로그래밍 언어가 다른 패러다임이나 설계를 따르지만 이 장에서 제시한 실제 작성 예시들은 이전 장에서 든 생각처럼 하나의 코드 베이스 또는 프로그램의 목적과 목적 달성을 위한 요구 사항을 추상화 한다고 했을 때, 무엇을 어떻게 대체해서 (목과 스텁을 활용해서) 무엇을 어떻게 테스트 할지를 좀 더 잘 이해하게 된 듯
  - '하나의 테스트에 스텁을 여러 개 사용하는 것은 괜찮지만, 목은 한 개만 사용하는 것이 좋다.'

[프런트엔드에서 의존성을 제어하는 법](https://twinstae.github.io/testing-with-dependency-injection/)
[함수형 프론트엔드에서 의존성 제어하기 : Wonderwall Tech](https://tech.wonderwall.kr/articles/functionaldependencymanagement/)
[테스트로 보는 DI - 함수와 변수 추출](https://twinstae.github.io/dependency-injection-extract/)
[마틴 파울러가 소개하는 소프트웨어 아키텍처](https://limdaeil.tistory.com/16)
[Prototype 이론과 JavaScript 설계 철학](https://velog.io/@easdkr/Prototype-이론과-JavaScript-설계-철학)
